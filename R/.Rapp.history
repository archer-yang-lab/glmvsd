library(glmvsd)#
library(glmnet)#
library(ncvreg)#
source("../../../googleproject/glmvsd/R/modelfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/tools.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/gaussianfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/binomialfit.R", chdir = TRUE)#
# if (!exists(".Random.seed")) runif(1)#
# initial.seed <- .Random.seed # keep track of the initial seed#
# save(initial.seed, file = paste("RandomSeed-1.rda", sep = ""))#
#
load(file = paste("RandomSeed-1.rda", sep = ""))#
assign(".Random.seed", initial.seed, .GlobalEnv)#
#
covmat <- function(rho, p) {#
  rho^(abs(outer(seq(p), seq(p), "-")))#
}#
#
n.sim <- 100#
n <- 200 #
p <- 8#
b <- c(3,1.5,0,0,2,0,0,0) #
true_m <- (1 - (b == 0))#
#
Sigma = covmat(0.5, p) # covariance matrix for covariates#
sqrtmat = chol(Sigma)#
VSD_mat <- matrix(NA,n.sim,16)#
x <- matrix(rnorm(n*p), n, p)#
# x = matrix(rnorm(n*p), n, p) %*% sqrtmat#
feta <- x %*% b #
fprob <- exp(feta)/(1+exp(feta))#
y <- rbinom(n, 1, fprob)#
#
cvfit <- cv.glmnet(x=x,y=y,alpha=1,maxit=1e6, family="binomial")#
tmp <- cvfit$glmnet.fit$beta#
beta.path <- as.matrix(tmp[,cvfit$lambda==cvfit$lambda.min])#
model_check <- drop(1 - (beta.path == 0))#
tmp <- true_m-model_check#
x=x#
y=y#
family="binomial"#
model_check=model_check#
weight_type="ARM"#
prior=TRUE#
n_train = ceiling(n/2) #
no_rep = 100#
psi = 1#
method = "union" #
y <- drop(y)#
y <- as.numeric(y)#
x <- as.matrix(x)#
p <- NCOL(x)#
n <- length(y)#
if (family == "binomial") {#
    if (!all(y %in% c(0, 1))) #
        stop("There can only be 0 or 1 in y when using binomial family")#
}#
# if (family == "tweedie") {#
#     if (any(y < 0)) #
#         stop("y must be nonzero when using Tweedie family")#
# }#
if (n != NROW(x)) #
    stop("x and y have different number of observations")#
if (n_train >= n) #
    stop("Training size must be less than the number of observations")#
if (missing(model_check)) #
    stop("User must provide a base model.")#
# use union option to compute candidate models#
if (method == "union") {#
    if (family == "gaussian") #
        candidate_models <- gaussianfit(x, y)#
    if (family == "binomial") #
        candidate_models <- binomialfit(x, y)#
    # if (family == "tweedie") #
    #     candidate_models <- tweediefit(x, y)#
}#
if (method == "customize") {#
    if (missing(candidate_models)) #
        stop("Users must supply a candidate model.")#
    if (is.matrix(candidate_models) != TRUE) #
        stop("Supplied model must be a matrix.")#
    if (NCOL(candidate_models) != NCOL(x)) #
        stop("Number of variables in candidate model and x does not match.")#
    if (!all(as.numeric(candidate_models) %in% c(0, 1))) #
        stop("There can only be 0 or 1 in candidate_models")#
}#
# clean the candidate models#
candidate_models <- unique(candidate_models)#
rownames(candidate_models) <- NULL#
candidate_models <- candidate_models[order(rowSums(candidate_models)), #
    ]#
candidate_models <- candidate_models[rowSums(candidate_models) < #
    (n_train - 2), ]
p <- NCOL(x)#
    n <- length(y)#
    n_mo <- NROW(candidate_models)#
    sk <- rowSums(candidate_models)#
    w_num <- matrix(NA, no_rep, n_mo)
library(glmvsd)#
library(glmnet)#
library(ncvreg)#
source("../../../googleproject/glmvsd/R/modelfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/tools.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/gaussianfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/binomialfit.R", chdir = TRUE)#
# if (!exists(".Random.seed")) runif(1)#
# initial.seed <- .Random.seed # keep track of the initial seed#
# save(initial.seed, file = paste("RandomSeed-1.rda", sep = ""))#
#
load(file = paste("RandomSeed-1.rda", sep = ""))#
assign(".Random.seed", initial.seed, .GlobalEnv)#
#
covmat <- function(rho, p) {#
  rho^(abs(outer(seq(p), seq(p), "-")))#
}#
#
n.sim <- 100#
n <- 200 #
p <- 8#
b <- c(3,1.5,0,0,2,0,0,0) #
true_m <- (1 - (b == 0))#
#
Sigma = covmat(0.5, p) # covariance matrix for covariates#
sqrtmat = chol(Sigma)#
VSD_mat <- matrix(NA,n.sim,16)#
x <- matrix(rnorm(n*p), n, p)#
# x = matrix(rnorm(n*p), n, p) %*% sqrtmat#
feta <- x %*% b #
fprob <- exp(feta)/(1+exp(feta))#
y <- rbinom(n, 1, fprob)#
#
cvfit <- cv.glmnet(x=x,y=y,alpha=1,maxit=1e6, family="binomial")#
tmp <- cvfit$glmnet.fit$beta#
beta.path <- as.matrix(tmp[,cvfit$lambda==cvfit$lambda.min])#
model_check <- drop(1 - (beta.path == 0))#
tmp <- true_m-model_check#
x=x#
y=y#
family="binomial"#
model_check=model_check#
weight_type="ARM"#
prior=TRUE#
n_train = ceiling(n/2) #
no_rep = 100#
psi = 1#
method = "union" #
y <- drop(y)#
y <- as.numeric(y)#
x <- as.matrix(x)#
p <- NCOL(x)#
n <- length(y)#
if (family == "binomial") {#
    if (!all(y %in% c(0, 1))) #
        stop("There can only be 0 or 1 in y when using binomial family")#
}#
# if (family == "tweedie") {#
#     if (any(y < 0)) #
#         stop("y must be nonzero when using Tweedie family")#
# }#
if (n != NROW(x)) #
    stop("x and y have different number of observations")#
if (n_train >= n) #
    stop("Training size must be less than the number of observations")#
if (missing(model_check)) #
    stop("User must provide a base model.")#
# use union option to compute candidate models#
if (method == "union") {#
    if (family == "gaussian") #
        candidate_models <- gaussianfit(x, y)#
    if (family == "binomial") #
        candidate_models <- binomialfit(x, y)#
    # if (family == "tweedie") #
    #     candidate_models <- tweediefit(x, y)#
}#
if (method == "customize") {#
    if (missing(candidate_models)) #
        stop("Users must supply a candidate model.")#
    if (is.matrix(candidate_models) != TRUE) #
        stop("Supplied model must be a matrix.")#
    if (NCOL(candidate_models) != NCOL(x)) #
        stop("Number of variables in candidate model and x does not match.")#
    if (!all(as.numeric(candidate_models) %in% c(0, 1))) #
        stop("There can only be 0 or 1 in candidate_models")#
}#
# clean the candidate models#
candidate_models <- unique(candidate_models)#
rownames(candidate_models) <- NULL#
candidate_models <- candidate_models[order(rowSums(candidate_models)), #
    ]#
candidate_models <- candidate_models[rowSums(candidate_models) < #
    (n_train - 2), ]#
    p <- NCOL(x)#
    n <- length(y)#
    n_mo <- NROW(candidate_models)#
    sk <- rowSums(candidate_models)#
    w_num <- matrix(NA, no_rep, n_mo)
no_rep=2
source("../../../googleproject/glmvsd/R/logitARMcore.R", chdir = TRUE)
for (i in 1:no_rep) {#
        w_num[i, ] <- logitARMcore(x, y, candidate_models, n_train, no_rep)#
    }
colSums(w_num)
rowSums(w_num)
for (i in 1:100) {#
        w_num[i, ] <- logitARMcore(x, y, candidate_models, n_train, no_rep)#
    }
weight <- apply(w_num/rowSums(w_num), 2, mean)
weight
sum(weight)
if(parallel){#
		outlist = foreach(i = seq(no_rep), .packages = c("glmvsd")) %dopar%{#
			logitARMcore(x, y, candidate_models, n_train, no_rep)#
		}
}
setwd('/Users/emeryyi/Dropbox/Research/89_glmvsd/code/GLMVSD_simulation')
library(foreach)
unlist(outlist)
as.matrix(unlist(outlist),no_rep,n_mo)
n_mo
no_rep
matrix(unlist(outlist),no_rep,n_mo)
w_num <- matrix(NA, no_rep, n_mo)
for (i in 1:no_rep) {#
	        w_num[i, ] <- logitARMcore(x, y, candidate_models, n_train, no_rep)#
	    }
w_num
outlist = foreach(i = seq(no_rep), .packages = c("glmvsd")) %dopar%{#
			logitARMcore(x, y, candidate_models, n_train, no_rep)#
		}
outlist
matrix(unlist(outlist),no_rep,n_mo,byrow=TRUE)
setwd('/Users/emeryyi/Dropbox/Research/googleproject/glmvsd/R')
if(parallel){#
		outlist = foreach(i = seq(no_rep), .packages = c("glmvsd")) %dopar%{#
			logitARMcore(x, y, candidate_models, n_train, no_rep)#
		} #
		w_num <- matrix(unlist(outlist),no_rep,n_mo,byrow=TRUE)#
	}else{#
		for (i in 1:no_rep) {#
	        w_num[i, ] <- logitARMcore(x, y, candidate_models, n_train, no_rep)#
	    }#
	}
