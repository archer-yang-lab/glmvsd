library(glmvsd)#
library(glmnet)#
library(ncvreg)#
# if (!exists(".Random.seed")) runif(1)#
# initial.seed <- .Random.seed # keep track of the initial seed#
# save(initial.seed, file = paste("RandomSeed-1.rda", sep = ""))#
#
ck_compute <- function(n_mo, sk, p) {#
	ck <- rep(NA, n_mo)#
	if (sk[1] == 0) {#
	    ck[1] <- 2 * log(sk[1] + 2)/choose(p, sk[1])#
	    ck[2:n_mo] <- sk[2:n_mo] * log(exp(1) * p/sk[2:n_mo]) + 2 * #
	        log(sk[2:n_mo] + 2)#
	} else {#
	    ck <- sk * log(exp(1) * p/sk) + 2 * log(sk + 2)#
	}#
	ck#
}#
#
gaussianfit <- function(x, y) {#
    lassofit <- glmnet(x = x, y = y, family = "gaussian", alpha = 1, maxit = 1e+06)#
    scadfit <- ncvreg(X = x, y = y, family = "gaussian", penalty = "SCAD", #
        warn = FALSE, max.iter = 1e+04)#
    mcpfit <- ncvreg(X = x, y = y, family = "gaussian", penalty = "MCP", #
        warn = FALSE, max.iter = 1e+04)#
    lasso.path <- as.matrix(lassofit$beta)#
    scad.path <- as.matrix(scadfit$beta[-1, ])#
    mcp.path <- as.matrix(mcpfit$beta[-1, ])#
    beta.path <- t(cbind(lasso.path, scad.path, mcp.path))#
    candidate_models <- (1 - (beta.path == 0))#
    candidate_models#
}#
binomialfit <- function(x, y) {#
    lassofit <- glmnet(x = x, y = y, family = "binomial", alpha = 1, maxit = 1e+06)#
    scadfit <- ncvreg(X = x, y = y, family = "binomial", penalty = "SCAD", #
        warn = FALSE, max.iter = 1e+04)#
    mcpfit <- ncvreg(X = x, y = y, family = "binomial", penalty = "MCP", #
        warn = FALSE, max.iter = 1e+04)#
    lasso.path <- as.matrix(lassofit$beta)#
    scad.path <- as.matrix(scadfit$beta[-1, ])#
    mcp.path <- as.matrix(mcpfit$beta[-1, ])#
    beta.path <- t(cbind(lasso.path, scad.path, mcp.path))#
    candidate_models <- (1 - (beta.path == 0))#
    candidate_models#
}#
#
load(file = paste("RandomSeed-1.rda", sep = ""))#
assign(".Random.seed", initial.seed, .GlobalEnv)#
n.sim <- 100#
n <- 100 #
p <- 40#
#
n_train = ceiling(n/2)#
no_rep = 10#
psi = 1#
family = "gaussian"#
method = "union"#
weight_type = "ARM"#
prior = TRUE#
#
b <- c(rep(3,15),rep(0,25))#
true_m <- (1 - (b == 0))#
#
VSD_mat <- matrix(NA,n.sim,19)#
z1<-rnorm(n,0,1)#
z2<-rnorm(n,0,1)#
z3<-rnorm(n,0,1)#
#
x1_5<-matrix(rnorm(n*5,0,0.1),ncol=5,nrow=n) + z1#
x6_10<-matrix(rnorm(n*5,0,0.1),ncol=5,nrow=n) + z2#
x11_15<-matrix(rnorm(n*5,0,0.1),ncol=5,nrow=n) + z3#
xrest<-matrix(rnorm(n*5,0,1),ncol=25,nrow=n)#
x <- cbind(x1_5,x6_10,x11_15,xrest)#
#
feta <- x %*% b #
fprob <- exp(feta)/(1+exp(feta))#
y <- rbinom(n, 1, fprob)#
#
cvfit <- cv.glmnet(x=x,y=y,alpha=0.95,maxit=1e6, family="binomial")#
tmp <- cvfit$glmnet.fit$beta#
beta.path <- as.matrix(tmp[,cvfit$lambda==cvfit$lambda.min])#
model_check <- drop(1 - (beta.path == 0))#
tmp <- true_m-model_check#
    y <- drop(y)#
    y <- as.numeric(y)#
    x <- as.matrix(x)#
    p <- NCOL(x)#
    n <- length(y)#
    if (family == "binomial") {#
        if (!all(y %in% c(0, 1))) #
            stop("There can only be 0 or 1 in y when using binomial family")#
    }#
    # if (family == "tweedie") {#
    #     if (any(y < 0)) #
    #         stop("y must be nonzero when using Tweedie family")#
    # }#
    if (n != NROW(x)) #
        stop("x and y have different number of observations")#
    if (n_train >= n) #
        stop("Training size must be less than the number of observations")#
    if (missing(model_check)) #
        stop("User must provide a base model.")#
    # use union option to compute candidate models#
    if (method == "union") {#
        if (family == "gaussian") #
            candidate_models <- gaussianfit(x, y)#
        if (family == "binomial") #
            candidate_models <- binomialfit(x, y)#
        # if (family == "tweedie") #
        #     candidate_models <- tweediefit(x, y)#
    }#
    if (method == "customize") {#
        if (missing(candidate_models)) #
            stop("Users must supply a candidate model.")#
        if (is.matrix(candidate_models) != TRUE) #
            stop("Supplied model must be a matrix.")#
        if (NCOL(candidate_models) != NCOL(x)) #
            stop("Number of variables in candidate model and x does not match.")#
        if (!all(as.numeric(candidate_models) %in% c(0, 1))) #
            stop("There can only be 0 or 1 in candidate_models")#
    }#
    # clean the candidate models#
    candidate_models <- unique(candidate_models)#
    rownames(candidate_models) <- NULL#
    candidate_models <- candidate_models[order(rowSums(candidate_models)), #
        ]#
    candidate_models <- candidate_models[rowSums(candidate_models) < #
        (n_train - 2), ]
p <- NCOL(x)#
    n <- length(y)#
    n_mo <- NROW(candidate_models)#
    sk <- rowSums(candidate_models)#
    dk <- matrix(NA, no_rep, n_mo)#
    sigma_k <- matrix(NA, no_rep, n_mo)
i=1
tindex <- sample(n, n_train, replace = F)#
        if (any(candidate_models[1, ] == 1)) {#
            for (j in 1:n_mo) {#
                LSL <- lm(y[tindex] ~ x[tindex, candidate_models[j, ] == #
                  1])#
                dk[i, j] <- sum((y[-tindex] - cbind(1, x[-tindex, candidate_models[j, #
                  ] == 1]) %*% LSL$coef)^2)#
                sigma_k[i, j] <- summary(LSL)$sigma#
            }#
        } else {#
            dk[i, 1] <- sum((y[-tindex] - mean(y[tindex]))^2)#
            sigma_k[i, 1] <- sd(y[tindex])#
            for (j in 2:n_mo) {#
                LSL <- lm(y[tindex] ~ x[tindex, candidate_models[j, ] == #
                  1])#
                dk[i, j] <- sum((y[-tindex] - cbind(1, x[-tindex, candidate_models[j, #
                  ] == 1]) %*% LSL$coef)^2)#
                sigma_k[i, j] <- summary(LSL)$sigma#
            }#
        }
dk[i, j] <- sum((y[-tindex] - cbind(1, x[-tindex, candidate_models[j, #
                  ] == 1]) %*% LSL$coef)^2)
LSL$coef
x[tindex, candidate_models[j, ] == #
                  1]
y[tindex]
length(dk)
lenght(y[tindex])
length(y[tindex])
lm(y[tindex] ~ x[tindex, candidate_models[j, ] == #
                  1])
summary(LSL)
summary(LSL)$sigma
Inf
exp(-Inf)
any(is.na(LSL$coef))
sigma_k[i, j] <- summary(LSL)$sigma
if(any(is.na(LSL$coef))){#
					dk[i, j] <- Inf#
					}else{#
				        dk[i, j] <- sum((y[-tindex] - cbind(1, x[-tindex, candidate_models[j, #
		                  ] == 1]) %*% LSL$coef)^2)#
					}
for (i in 1:no_rep) {#
        tindex <- sample(n, n_train, replace = F)#
        if (any(candidate_models[1, ] == 1)) {#
            for (j in 1:n_mo) {#
                LSL <- lm(y[tindex] ~ x[tindex, candidate_models[j, ] == #
                  1])#
                sigma_k[i, j] <- summary(LSL)$sigma#
				if(any(is.na(LSL$coef))){#
					dk[i, j] <- Inf#
					}else{#
				        dk[i, j] <- sum((y[-tindex] - cbind(1, x[-tindex, candidate_models[j, #
		                  ] == 1]) %*% LSL$coef)^2)#
					}#
            }#
        } else {#
            dk[i, 1] <- sum((y[-tindex] - mean(y[tindex]))^2)#
            sigma_k[i, 1] <- sd(y[tindex])#
            for (j in 2:n_mo) {#
                LSL <- lm(y[tindex] ~ x[tindex, candidate_models[j, ] == #
                  1])#
	            sigma_k[i, j] <- summary(LSL)$sigma		#
				if(any(is.na(LSL$coef))){#
					dk[i, j] <- Inf#
					}else{#
				        dk[i, j] <- sum((y[-tindex] - cbind(1, x[-tindex, candidate_models[j, #
		                  ] == 1]) %*% LSL$coef)^2)#
					}#
            }#
        }#
    }
dk
sigma
lw_num <- (-n/2) * log(sigma_k) - ((sigma_k)^(-2)) * dk/2
lw_num
if (prior == TRUE) {#
        ck <- ck_compute(n_mo, sk, p)#
        lw_num <- sweep(lw_num, MARGIN = 2, psi * ck, "-")#
    }
lw_num <- sweep(lw_num, MARGIN = 1, apply(lw_num, 1, max), "-")
w_num <- apply(lw_num, c(1, 2), function(x) ifelse(abs(x) > 700, 0, #
        exp(x)))
weight <- apply(w_num/rowSums(w_num), 2, mean)
setwd('/Users/emeryyi/Dropbox/Research/googleproject/glmvsd/R')
weight
