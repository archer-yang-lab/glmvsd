setwd('/Users/emeryyi/Dropbox/Research/89_glmvsd/code/GLMVSD_simulation')
library(glmvsd)#
library(glmnet)#
library(reshape2)#
library(ncvreg)#
library(foreach)#
library(doParallel)#
registerDoParallel(2)#
source("../../../googleproject/glmvsd/R/modelfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/tools.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/gaussianfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/gaussianfit.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/logitARMcore.R", chdir = TRUE)#
source("../../../googleproject/glmvsd/R/lsARMcore.R", chdir = TRUE)#
# if (!exists(".Random.seed")) runif(1)#
# initial.seed <- .Random.seed # keep track of the initial seed#
# save(initial.seed, file = paste("RandomSeed-1.rda", sep = ""))#
#
load(file = paste("RandomSeed-1.rda", sep = ""))#
assign(".Random.seed", initial.seed, .GlobalEnv)#
#
covmat <- function(rho, p) {#
  rho^(abs(outer(seq(p), seq(p), "-")))#
}#
#
n.sim <- 100#
n <- 200 #
p <- 8#
b <- c(3,1.5,0,0,2,0,0,0) #
true_m <- (1 - (b == 0))#
#
Sigma = covmat(0.5, p) # covariance matrix for covariates#
sqrtmat = chol(Sigma)#
VSD_mat <- matrix(NA,n.sim,16)#
x <- matrix(rnorm(n*p), n, p)#
# x = matrix(rnorm(n*p), n, p) %*% sqrtmat#
feta <- x %*% b #
y <- feta + rnorm(n)#
#
cvfit <- cv.glmnet(x=x,y=y,alpha=1,maxit=1e6, family="gaussian")#
tmp <- cvfit$glmnet.fit$beta#
beta.path <- as.matrix(tmp[,cvfit$lambda==cvfit$lambda.min])#
model_check <- drop(1 - (beta.path == 0))#
tmp <- true_m-model_check#
x=x#
y=y#
family="gaussian"#
model_check=model_check#
weight_type="ARM"#
prior=TRUE#
n_train = ceiling(n/2) #
no_rep = 100#
psi = 1#
method = "union" #
y <- drop(y)#
y <- as.numeric(y)#
x <- as.matrix(x)#
p <- NCOL(x)#
n <- length(y)#
if (family == "gaussian") {#
    if (!all(y %in% c(0, 1))) #
        stop("There can only be 0 or 1 in y when using gaussian family")#
}#
# if (family == "tweedie") {#
#     if (any(y < 0)) #
#         stop("y must be nonzero when using Tweedie family")#
# }#
if (n != NROW(x)) #
    stop("x and y have different number of observations")#
if (n_train >= n) #
    stop("Training size must be less than the number of observations")#
if (missing(model_check)) #
    stop("User must provide a base model.")#
# use union option to compute candidate models#
if (method == "union") {#
    if (family == "gaussian") #
        candidate_models <- gaussianfit(x, y)#
    if (family == "gaussian") #
        candidate_models <- gaussianfit(x, y)#
    # if (family == "tweedie") #
    #     candidate_models <- tweediefit(x, y)#
}#
if (method == "customize") {#
    if (missing(candidate_models)) #
        stop("Users must supply a candidate model.")#
    if (is.matrix(candidate_models) != TRUE) #
        stop("Supplied model must be a matrix.")#
    if (NCOL(candidate_models) != NCOL(x)) #
        stop("Number of variables in candidate model and x does not match.")#
    if (!all(as.numeric(candidate_models) %in% c(0, 1))) #
        stop("There can only be 0 or 1 in candidate_models")#
}#
# clean the candidate models#
candidate_models <- unique(candidate_models)#
rownames(candidate_models) <- NULL#
candidate_models <- candidate_models[order(rowSums(candidate_models)), #
    ]#
candidate_models <- candidate_models[rowSums(candidate_models) < #
    (n_train - 2), ]#
#
   p <- NCOL(x)#
    n <- length(y)#
    n_mo <- NROW(candidate_models)#
    sk <- rowSums(candidate_models)#
    dk <- matrix(NA, no_rep, n_mo)#
    sigma_k <- matrix(NA, no_rep, n_mo)
p <- NCOL(x)#
    n <- length(y)#
    n_mo <- NROW(candidate_models)#
    sk <- rowSums(candidate_models)#
    dk <- matrix(NA, no_rep, n_mo)#
    sigma_k <- matrix(NA, no_rep, n_mo)
outlist = foreach(i = seq(no_rep), .packages = c("glmvsd")) %dopar%{#
			lsARMcore(x, y, candidate_models, n_train, no_rep)#
		}#
		res <- melt(outlist)#
		sigma_k <- matrix(res$value[res$L2=="sigma_k"],no_rep,n_mo,byrow=TRUE)#
		dk <- matrix(res$value[res$L2=="dk"],no_rep,n_mo,byrow=TRUE)
setwd('/Users/emeryyi/Dropbox/Research/googleproject/glmvsd/R')
lw_num <- (-n/2) * log(sigma_k) - ((sigma_k)^(-2)) * dk/2#
    if (prior == TRUE) {#
        ck <- ck_compute(n_mo, sk, p)#
        lw_num <- sweep(lw_num, MARGIN = 2, psi * ck, "-")#
    }#
    lw_num <- sweep(lw_num, MARGIN = 1, apply(lw_num, 1, max), "-")#
    w_num <- apply(lw_num, c(1, 2), function(x) ifelse(abs(x) > 700, 0, #
        exp(x)))#
    weight <- apply(w_num/rowSums(w_num), 2, mean)
weight
sum(weight)
model_check
